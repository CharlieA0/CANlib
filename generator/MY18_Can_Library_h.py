"""
Generate MY18_Can_Libary.h file.
Run this file to write just MY18_Can_Libary.h or main.py to write all files.
"""
import sys
sys.path.append("ParseCAN")
import ParseCAN
from common import can_lib_h_path, spec_path, boards_paths


def write(output_path, spec_path, boards_paths):
    """
    Generate MY18_Can_Libary.h file.

    :param output_path: file to be written to
    :param spec_path: CAN spec path
    :param struct_paths: list of paths to struct header files (the ones generated by structs.py)
    :param unused_messages: list of messages that are in the CAN spec but unused
    """
    spec = ParseCAN.spec.can(spec_path)
    with open(output_path, 'w') as f:
        # Setup file
        f.write("#ifndef _MY18_CAN_LIBRARY_H\n" +
                "#define _MY18_CAN_LIBRARY_H\n\n")

        # Include static stuff
        f.write('#include "static_can.h"\n\n')

        # Create enum
        f.write("typedef enum {\n" +
                "  Can_No_Msg,\n" +
                "  Can_Unknown_Msg,\n" +
                "  Can_Error_Msg,\n")
        for message in spec.messages.values():
            f.write("  Can_" + message.name + "_Msg,\n")

        # Add board includes
        for path in boards_paths:
            f.write('#include "' + path.replace("..", "").replace("/", "") + '"\n')

        # Write DECLARE statements
        for message in spec.messages.values():
            f.write("DECLARE(Can_" + message.name + ")\n")

        # Finish up
        f.write(
            "#undef DECLARE\n" +
            "#endif // _MY18_CAN_LIBRARY_H")


if __name__ == "__main__":
    write(can_lib_h_path, spec_path, boards_paths.values())
