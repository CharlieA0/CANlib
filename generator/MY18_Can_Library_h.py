"""
Generate MY18_Can_Libary.h file.
Run this file to write just MY18_Can_Libary.h or main.py to write all files.
"""
import sys
sys.path.append("ParseCAN")
import ParseCAN
from common import can_lib_h_path, spec_path


def write(output_path, spec_path):
    """
    Generate MY18_Can_Libary.h file.

    :param output_path: file to be written to
    :param spec_path: CAN spec path
    :param struct_paths: list of paths to struct header files (the ones generated by structs.py)
    :param unused_messages: list of messages that are in the CAN spec but unused
    """
    car = ParseCAN.spec.car(spec_path)
    with open(output_path, 'w') as f:
        # Setup file
        f.write("#ifndef _MY18_CAN_LIBRARY_H\n" +
                "#define _MY18_CAN_LIBRARY_H\n\n")

        # Includes
        f.write("#include <stdint.h>\n" +
                "#include <stdbool.h>\n\n")

        # Create enum
        f.write("typedef enum {\n" +
                "  Can_No_Msg,\n" +
                "  Can_Unknown_Msg,\n" +
                "  Can_Error_Msg,\n")
        for bus in car.buses.values():
            for message in bus.messages:
                f.write("  Can_" + message.name + "_Msg,\n")
        f.write("} Can_MsgID_T;\n\n")

        f.write("Can_MsgID_T Can_MsgType(void);\n\n")

        # Include static stuff
        f.write('#include "static_can.h"\n\n')

        # Add board includes
        for board in car.boards.keys():
            f.write('#include "boards/' + board + '.h"\n')
        f.write("\n")

        # Write DECLARE statements
        for bus in car.buses.values():
            for message in bus.messages:
                f.write("DECLARE(Can_" + message.name + ")\n")

        # Finish up
        f.write("#endif // _MY18_CAN_LIBRARY_H")


if __name__ == "__main__":
    write(can_lib_h_path, spec_path)
