'''
Generate Can_Libary.c file.
Run this file (with the spec path as a command line argument) to write just
Can_Libary.c or main.py to write all files.
'''
import sys
sys.path.append('ParseCAN')
import ParseCAN
from ParseCAN.spec import Endianness, Type

from math import ceil, floor, log2
from common import can_lib_c_path, can_lib_c_base_path, coord, is_multplxd, frame_handler


def swap_endianness_fn(type: Type):
    if type.isbool():
        return ''

    return 'swap_' + type.type


def write_atoms_unpack(fw, atoms, tot_name):
    for atom in atoms:
        if atom.type.isenum():
            enum_name = coord(tot_name, atom.name) + '_T'

            fw(
                '\t' 'type_out->' + atom.name + ' = (' + enum_name + ')EXTRACT(bitstring, ' +
                str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n'
            )
        elif atom.type.type == 'bool':
            fw(
                '\t' 'type_out->' + atom.name + ' = EXTRACT(bitstring, ' + str(atom.slice.start) + ', ' +
                str(atom.slice.length) + ');' '\n'
            )
        else:
            if atom.type.endianness == Endianness.LITTLE:
                fw(
                    '\t' 'type_out->' + atom.name + ' = ' + swap_endianness_fn(atom.type) +
                    '(EXTRACT(bitstring, ' + str(atom.slice.start) + ', ' +
                    str(atom.slice.length) + '));' '\n'
                )
            else:
                if atom.type.issigned():
                    fw(
                        '\t' 'type_out->' + atom.name + ' = SIGN(EXTRACT(bitstring, ' +
                        str(atom.slice.start) + ', ' + str(atom.slice.length) + '), ' +
                        str(atom.slice.length) + ');' '\n'
                    )
                else:
                    fw(
                        '\t' 'type_out->' + atom.name + ' = EXTRACT(bitstring, ' +
                        str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n'
                    )


def write_can_unpack(frame, name_prepends, fw, *args):
    tot_name = coord(name_prepends, frame.name, prefix=False)
    fw(
        'CAN_UNPACK(' + tot_name + ') {' '\n'
        '\t' 'uint64_t bitstring = 0;' '\n'
        '\t' 'to_bitstring(can_in->data, &bitstring);\n'
    )

    write_atoms_unpack(fw, frame.atom, tot_name)

    fw('}' '\n\n')


def write_can_pack(frame, name_prepends, is_multplxd, bus_ext, fw, *args):
    fw('CAN_PACK(' + coord(name_prepends, frame.name, prefix=False) + ') {' '\n'
        '\t' 'uint64_t bitstring = 0;' '\n'
    )

    write_atoms_pack(fw, frame.atom)

    length = max(atom.slice.start + atom.slice.length for atom in frame.atom)

    fw(
        '\t' 'from_bitstring(&bitstring, can_out->data);' '\n'
    )
    if (is_multplxd):
        fw('\t' 'can_out->id = {}_key;'.format(coord(name_prepends)) + '\n')
    fw(
        '\t' 'can_out->dlc = ' + str(ceil(length / 8)) + ';' '\n'
        '\t' 'can_out->extended = ' + str(bus_ext).lower() + ';' '\n'
        '}' '\n\n'
    )


def write_atoms_pack(fw, atoms):
    for atom in atoms:
        # HACK/TODO: This is assuming big endian systems that run CANlib
        if atom.type.endianness == Endianness.LITTLE:
            fw(
                '\t' 'bitstring = INSERT(' + swap_endianness_fn(atom.type) + '(type_in->' + atom.name + '), bitstring, ' +
                str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n\n'
            )
        else:
            fw(
                '\t' 'bitstring = INSERT(type_in->' + atom.name + ', bitstring, ' + str(atom.slice.start) +
                ', ' + str(atom.slice.length) + ');' '\n'
            )


def write(can, output_path=can_lib_c_path, base_path=can_lib_c_base_path):
    '''
    Generate Can_Libary.c file.

    :param output_path: file to be written to
    :param can: CAN spec
    :param base_path: File with template code that's not autogenerated
    '''
    with open(output_path, 'w') as f:
        fw = f.write

        fw('#include "CANlib.h"\n')

        # Copy over base
        with open(base_path) as base:
            lines = base.readlines()
            f.writelines(lines)

        fw('\n')

        for bus in can.bus:
            # Write switch statement
            fw((
                '{}_T CANlib_Identify_{}(Frame* frame)'.format(coord(bus.name), coord(bus.name, prefix=False)) + '{' '\n'
                '\t' 'uint64_t bitstring = 0;' '\n'
                '\t' 'switch(frame->id) {' '\n'
            ))

            def single_handler(frame, name_prepends, num_tabs):
                fw(
                    '\t' * num_tabs + 'case {}_key:'.format(coord(name_prepends, frame.name)) + '\n' +
                    '\t' * (num_tabs + 1) + 'return {};\n'.format(coord(name_prepends, frame.name))
                )

            def multplxd_handler(frame, name_prepends, num_tabs):
                fw('\t' * num_tabs + 'case {}_key:\n'.format(coord(name_prepends, frame.name)))
                key_size = ceil(frame.slice.length / 8) * 8
                key_name = '_'.join([name_prepends,frame.name, 'key'])
                fw('\t' * (num_tabs + 1) + 'to_bitstring(frame->data, &bitstring);' '\n')
                key_name = '_'.join([name_prepends,frame.name, 'key'])
                fw(
                    '\t' * (num_tabs + 1) + 'uint{}_t {} = EXTRACT(bitstring, {}, {});\n'.format(key_size, key_name, frame.slice.start, frame.slice.length) + '\t' * (num_tabs + 1) + 'switch(' + key_name + ') {' '\n'
                )

                name_prepends += '_' + frame.name

                for sub_frame in frame.frame:
                    if is_multplxd(sub_frame):
                        multplxd_handler(sub_frame, name_prepends, num_tabs + 2)
                    else:
                        single_handler(sub_frame, name_prepends, num_tabs + 2)
                fw(
                    '\t' * (num_tabs + 2) + 'default:\n' +
                    '\t' * (num_tabs + 3) + 'return CAN_UNKNOWN_MSG;\n' +
                    '\t' * (num_tabs + 1) + '}\n'
                )

            for msg in bus.frame:
                if is_multplxd(msg):
                    multplxd_handler(msg, bus.name, 2)
                else:
                    single_handler(msg, bus.name, 2)
            fw(
                '\t' '\t' 'default:' '\n'
                '\t' '\t' '\t' 'return CAN_UNKNOWN_MSG;' '\n'
                '\t' '}' '\n'
                '}' '\n\n'
            )

        for bus in can.bus:
            for msg in bus.frame:
                frame_handler(msg, bus.name, write_can_pack, is_multplxd(msg), bus.extended, fw)

                frame_handler(msg, bus.name, write_can_unpack, fw)

        # Write DEFINE statements
        for bus in can.bus:
            for msg in bus.frame:
                if is_multplxd(msg):
                    for frame in msg.frame:
                            fw('DEFINE(' + coord(bus.name, msg.name, frame.name, prefix=False) +
                              ', ' + bus.name + ')\n')
                else:
                    fw('DEFINE(' + coord(bus.name, msg.name, prefix=False) + ', ' + bus.name + ')\n')
