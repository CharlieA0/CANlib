"""
Generate Can_Libary.h file.
Run this file (with the spec path as a command line argument) to write just
Can_Libary.h or main.py to write all files.
"""
import sys
sys.path.append("ParseCAN")
import ParseCAN
from common import can_lib_h_path


def write(output_path, spec_path):
    """
    Generate Can_Libary.h file.

    :param output_path: file to be written to
    :param spec_path: CAN spec path
    :param struct_paths: list of paths to struct header files (the ones generated by structs.py)
    :param unused_messages: list of messages that are in the CAN spec but unused
    """
    car = ParseCAN.spec.car(spec_path)
    with open(output_path, 'w') as f:
        # Setup file
        f.write("#ifndef _CAN_LIBRARY_H\n" +
                "#define _CAN_LIBRARY_H\n\n")

        # Includes
        f.write("#include <stdint.h>\n" +
                "#include <stdbool.h>\n\n")

        # Create enum
        f.write("typedef enum {\n" +
                "  Can_No_Msg,\n" +
                "  Can_Unknown_Msg,\n" +
                "  Can_Error_Msg,\n")
        for bus in car.buses.values():
            for message in bus.messages:
                f.write("  Can_" + message.name + "_Msg,\n")
        f.write("} Can_MsgID_T;\n\n")

        f.write("Can_MsgID_T Can_MsgType(void);\n\n")

        # Include static stuff
        f.write('#include "static_can.h"\n\n')

        # Add board includes
        for board in car.boards.keys():
            f.write('#include "boards/' + board + '.h"\n')
        f.write("\n")

        # Write DECLARE statements
        for bus in car.buses.values():
            for message in bus.messages:
                f.write("DECLARE(Can_" + message.name + ")\n")
        f.write("\n")

        # Declare inits
        for board in car.boards.values():
            if board.arch:  # Means it's a board we program
                for bus_name, bus in board.subscribe.items():
                    f.write("void " + bus_name.title() + "_" + board.name.title() +
                            "_Init(uint32_t baudrate);\n")
                for bus_name, bus in board.publish.items():
                    if bus_name not in board.subscribe.keys():
                        f.write("void " + bus_name.title() + "_" + board.name.title() +
                                "_Init(uint32_t baudrate);\n")
        f.write("\n")

        # Finish up
        f.write("#endif // _CAN_LIBRARY_H")


if __name__ == "__main__":
    spec_path = sys.argv[1]
    write(can_lib_h_path, spec_path)
