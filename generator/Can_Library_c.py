"""
Generate Can_Libary.c file.
Run this file (with the spec path as a command line argument) to write just
Can_Libary.c or main.py to write all files.
"""
import sys
sys.path.append("ParseCAN")
import ParseCAN
from math import ceil
from common import can_lib_c_path, can_lib_c_base_path


def write(output_path, spec_path, base_path):
    """
    Generate Can_Libary.c file, where CAR_NAME is the name of .

    :param output_path: file to be written to
    :param spec_path: CAN spec path
    :param base_path: File with template code that's not autogenerated
    """
    car = ParseCAN.spec.car(spec_path)
    with open(output_path, 'w') as f:
        f.write('#include "Can_Library.h"')

        # Copy over base
        with open(base_path) as base:
            lines = base.readlines()
            f.writelines(lines)

        # Write switch statement
        f.write("""Can_MsgID_T Can_MsgType(void) {
  lastError = Can_RawRead(&lastMessage);
  if (lastError == Can_Error_NO_RX) {
    return Can_No_Msg;
  } else if (lastError != Can_Error_NONE) {
    return Can_Error_Msg;
  }

  uint32_t id = lastMessage.id;

  switch(id) {
""")
        for bus in car.buses.values():
            for message in bus.messages:
                f.write(
                    "    case " + message.name.upper() + "__id:\n" +
                    "      return Can_" + message.name + "_Msg;\n")

        f.write(
            "    default:\n" +
            "      return Can_Unknown_Msg;\n" +
            "   }\n" +
            "}\n\n")

        for bus in car.buses.values():
            for message in bus.messages:

                # Write TO_CAN
                f.write(
                    "TO_CAN(Can_" + message.name + ") {\n" +
                    "  uint64_t bitstring = 0;\n")

                length = 0
                for segment in message.segments:
                    if not message.is_big_endian and (segment.c_type.startswith("int") or
                                                      segment.c_type.startswith("uint")):
                        f.write(
                            "  " + segment.c_type + " " + segment.name + "_swap_value = swap_" + segment.c_type[:-2] +
                            "(type_in->" + segment.name + ");\n" + "  bitstring = INSERT(" + segment.name +
                            "_swap_value, bitstring, " + str(segment.position) + ", " + str(segment.length) + ");\n\n")
                    else:
                        f.write(
                            "  bitstring = INSERT(type_in->" + segment.name + ", bitstring, " + str(segment.position) +
                            ", " + str(segment.length) + ");\n")

                    length += segment.length
                f.write(
                    "  from_bitstring(&bitstring, can_out->data);\n" +
                    "  can_out->id = " + message.name.upper() + "__id;\n" +
                    "  can_out->len = " + str(ceil(length / 8)) + ";\n" +
                    "}\n\n")

                # Write FROM_CAN
                f.write(
                    "FROM_CAN(Can_" + message.name + ") {\n" +
                    "  uint64_t bitstring = 0;\n" +
                    "  to_bitstring(can_in->data, &bitstring);\n")
                for segment in message.segments:
                    if segment.c_type == "enum":
                        enum_name = "Can_" + message.name + "ID_T"

                        f.write(
                            "  type_out->" + segment.name + " = (" + enum_name + ")EXTRACT(bitstring, " +
                            str(segment.position) + ", " + str(segment.length) + ");\n")
                    elif segment.c_type == "bool":
                        f.write(
                            "  type_out->" + segment.name + " = EXTRACT(bitstring, " + str(segment.position) + ", " +
                            str(segment.length) + ");\n")
                    else:
                        if not message.is_big_endian:
                            if segment.signed:
                                f.write(
                                    "  " + segment.c_type + " " + segment.name + "_swap_value=(swap_" +
                                    segment.c_type[:-2] + "(EXTRACT(bitstring, " + str(segment.position) + ", " +
                                    str(segment.length) + ")));\n")
                            else:
                                f.write(
                                    "  " + segment.c_type + " " + segment.name + "_swap_value=swap_u" +
                                    segment.c_type[:-2] + "(EXTRACT(bitstring, " + str(segment.position) + ", " +
                                    str(segment.length) + ")));\n")
                            f.write("  type_out->" + segment.name + " = " + segment.name + "_swap_value;\n")
                        else:
                            if segment.signed:
                                f.write(
                                    "  type_out->" + segment.name + " = SIGN(EXTRACT(bitstring, " +
                                    str(segment.position) + ", " + str(segment.length) + "), " +
                                    str(segment.length) + ");\n")
                            else:
                                f.write(
                                        "  type_out->" + segment.name + " = EXTRACT(bitstring, " +
                                        str(segment.position) + ", " + str(segment.length) + ");\n")
                f.write("}\n\n")

        # Write DEFINE statements
        for bus in car.buses.values():
            for message in bus.messages:
                f.write("DEFINE(Can_" + message.name + ")\n")


if __name__ == "__main__":
    spec_path = sys.argv[1]
    write(can_lib_c_path, spec_path, can_lib_c_base_path)
