'''
Generate Can_Libary.c file.
Run this file (with the spec path as a command line argument) to write just
Can_Libary.c or main.py to write all files.
'''
import sys
sys.path.append('ParseCAN')
import ParseCAN
from ParseCAN.spec import Endianness, Type

from math import ceil, floor, log2
from common import can_lib_c_path, can_lib_c_base_path, coord, is_multplxd, frame_handler


def swap_endianness_fn(type: Type):
    if type.isbool():
        return ''

    return 'swap_' + type.type


def write_atoms_unpack(fw, atoms, tot_name):
    for atom in atoms:
        if atom.type.isenum():
            enum_name = coord(tot_name, atom.name) + '_T'

            fw(
                '\t' 'type_out->' + atom.name + ' = (' + enum_name + ')EXTRACT(bitstring, ' +
                str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n'
            )
        elif atom.type.type == 'bool':
            fw(
                '\t' 'type_out->' + atom.name + ' = EXTRACT(bitstring, ' + str(atom.slice.start) + ', ' +
                str(atom.slice.length) + ');' '\n'
            )
        else:
            if atom.type.endianness == Endianness.LITTLE:
                fw(
                    '\t' 'type_out->' + atom.name + ' = ' + swap_endianness_fn(atom.type) +
                    '(EXTRACT(bitstring, ' + str(atom.slice.start) + ', ' +
                    str(atom.slice.length) + '));' '\n'
                )
            else:
                if atom.type.issigned():
                    fw(
                        '\t' 'type_out->' + atom.name + ' = SIGN(EXTRACT(bitstring, ' +
                        str(atom.slice.start) + ', ' + str(atom.slice.length) + '), ' +
                        str(atom.slice.length) + ');' '\n'
                    )
                else:
                    fw(
                        '\t' 'type_out->' + atom.name + ' = EXTRACT(bitstring, ' +
                        str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n'
                    )


def write_can_unpack(frame, name_prepends, fw, *args):
    tot_name = coord(name_prepends, frame.name, prefix=False)
    fw(
        'void CANlib_Unpack_' + tot_name +'(Frame *can_in, CANlib_' + tot_name +
        '_T *type_out){\n'
        '\t' 'uint64_t bitstring = 0;' '\n'
        '\t' 'to_bitstring(can_in->data, &bitstring);\n'
    )

    write_atoms_unpack(fw, frame.atom, tot_name)

    fw('}' '\n\n')


def write_can_pack(frame, name_prepends, is_multplxd, bus_ext, fw, *args):
    tot_name = coord(name_prepends, frame.name, prefix=False)
    fw(
        'void CANlib_Pack_' + tot_name + '(CANlib_' + tot_name + '_T *type_in, Frame *can_out)'
        '{\n\t' 'uint64_t bitstring = 0;' '\n'
    )

    write_atoms_pack(fw, frame.atom)

    length = max(atom.slice.start + atom.slice.length for atom in frame.atom)

    fw(
        '\t' 'from_bitstring(&bitstring, can_out->data);' '\n'
    )
    if (is_multplxd):
        fw('\t' 'can_out->id = {}_key;'.format(coord(name_prepends)) + '\n')
    fw(
        '\t' 'can_out->dlc = ' + str(ceil(length / 8)) + ';' '\n'
        '\t' 'can_out->extended = ' + str(bus_ext).lower() + ';' '\n'
        '}' '\n\n'
    )


def write_atoms_pack(fw, atoms):
    for atom in atoms:
        # HACK/TODO: This is assuming big endian systems that run CANlib
        if atom.type.endianness == Endianness.LITTLE:
            fw(
                '\t' 'bitstring = INSERT(' + swap_endianness_fn(atom.type) + '(type_in->' + atom.name + '), bitstring, ' +
                str(atom.slice.start) + ', ' + str(atom.slice.length) + ');' '\n\n'
            )
        else:
            fw(
                '\t' 'bitstring = INSERT(type_in->' + atom.name + ', bitstring, ' + str(atom.slice.start) +
                ', ' + str(atom.slice.length) + ');' '\n'
            )


def write_define(frame, name_prepends, busnm, fw):
    fw('DEFINE(' + coord(name_prepends, frame.name, prefix=False) + ', ' + busnm + ')\n')


def write(can, output_path=can_lib_c_path, base_path=can_lib_c_base_path):
    '''
    Generate Can_Libary.c file.

    :param output_path: file to be written to
    :param can: CAN spec
    :param base_path: File with template code that's not autogenerated
    '''
    with open(output_path, 'w') as f:
        fw = f.write

        fw('#include "pack_unpack.h"\n')

        # Copy over base
        with open(base_path) as base:
            lines = base.readlines()
            f.writelines(lines)

        fw('\n')

        for bus in can.bus:
            for msg in bus.frame:
                frame_handler(msg, bus.name, write_can_pack, is_multplxd(msg),
                    bus.extended, fw)
                frame_handler(msg, bus.name, write_can_unpack, fw)
                frame_handler(msg, bus.name, write_define, bus.name, fw)
